var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Basic-Usage","page":"API","title":"Basic Usage","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Here is an example illustrating the basic API for univariate functions.","category":"page"},{"location":"api/","page":"API","title":"API","text":"using PolyhderalRelaxations, JuMP\nm = Model() \nJuMP.@variable(m, -1.0 <= x <= 1.0)\nJuMP.@variable(m, y)\nf = x -> x^3\nconstruct_univariate_relaxation!(m, f, x, y, [-1.0, 0.0, 1.0], true)","category":"page"},{"location":"api/","page":"API","title":"API","text":"For bilinear functions, the basic API is as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using PolyhderalRelaxations, JuMP\nm = Model() \nJuMP.@variable(m, -1.0 <= x <= 1.0)\nJuMP.@variable(m, -10.0 <= y <= 12.0)\nJuMP.@variable(m, z)\nconstruct_bilinear_relaxation!(m, x, y, z, [-1.0, 1.0], [-10.0, 12.0])","category":"page"},{"location":"api/","page":"API","title":"API","text":"If there is only one partition (like above) for each variable, then the function formulates the McCormick relaxation. The package supports more than one partition only one of the variables x or y. Support for multi-variable partitioning will be added in the future versions. The following example illustrates the API for more than one partitions on the x2 variable:","category":"page"},{"location":"api/","page":"API","title":"API","text":"using PolyhderalRelaxations, JuMP\nm = Model() \nJuMP.@variable(m, -1.0 <= x1 <= 1.0)\nJuMP.@variable(m, -1.0 <= x2 <= 1.0)\nJuMP.@variable(m, z)\nconstruct_bilinear_relaxation!(m, x1, x2, z, [-1.0, 1.0], [-1.0, -0.25, 0.25, 1.0])","category":"page"},{"location":"api/","page":"API","title":"API","text":"For examples, the reader is referred to the unit tests in the test/ folder of the GitHub repository. ","category":"page"},{"location":"api/#API-for-the-MILP/LP-Relaxation-for-Nonlinear-Univariate-function","page":"API","title":"API for the MILP/LP Relaxation for Nonlinear Univariate function","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API documentation for both the MILP and the LP relaxations for a given nonlinear univariate function is as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"construct_univariate_relaxation!","category":"page"},{"location":"api/#PolyhedralRelaxations.construct_univariate_relaxation!","page":"API","title":"PolyhedralRelaxations.construct_univariate_relaxation!","text":"construct_univariate_relaxation!(m,f,x,y,x_partition;f_dash=x->ForwardDiff.derivative(f,x),error_tolerance=NaN64,length_tolerance=1e-6,derivative_tolerance=1e-6,num_additional_partitions=0)\n\nAdd MILP relaxation of y=f(x) to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::JuMP.Model: model to which relaxation is to be added.\nf::Function: function or oracle for which a polyhedral relaxation is   required, usually non-linear.\nx::JuMP.VariableRef: JuMP variable for domain of f.\ny::JuMP.VariableRef: JuMP variable for evaluation of f.\nx_partition::Vector{<:Real}: partition of the domain of f.\nmilp::Bool: build MILP relaxation if true, LP relaxation otherwise. Note   that the MILP relaxation uses the incremental formulation presented in the   paper, but the LP relaxation uses a lambda form that builds a formulation   as the convex combination of triangle vertices that are at the intersection   of tangents to the curve.\n\nOptional Arguments\n\nf_dash::Function: function or oracle for derivative of f, defaults to    the derivative function from the ForwardDiff package.\nerror_tolerance::Float64: Maximum allowed vertical distance between over   and under estimators of f, defaults to NaN64.\nlength_tolerance::Float64: maximum length of a sub-interval in a partition,   defaults to 1 times 10^-6.\nderivative_tolerance::Float64: minimum absolute difference between   derivaties at successive elements of a partition for them to be considered   different, defaults to 1 times 10^-6. If the difference of a partition sub-interval   is smaller than this value, that sub-interval will be refined.\nnum_additional_partitions::Int64: budget on number of sub-intervals in   partition, defaults to 0. Note that if the number of partitions is n and   the number of additional partitions is m, then the function will return a   relaxation with at most n+m partitions.\nvariable_pre_base_name::AbstractString: base_name that needs to be added to the auxiliary   variables for meaningful LP files\n\nAssume that:\n\nf is a bounded function of 1 variable.\nx_partition is a partition of the domain of f such that f is either   convex or concave each sub-interval of the partition.\nf_dash is not equal at two consecutive elements of x_partition.\n\nThis function builds an incremental formulation, which is the formulation presented in the paper.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"The derivate of the function is an optional keyword argument. If the derivate is not specified, the package invokes ForwardDiff.jl to compute the derivative.","category":"page"},{"location":"api/#API-for-the-MILP/LP-Relaxation-for-Bilinear-Term","page":"API","title":"API for the MILP/LP Relaxation for Bilinear Term","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The API for both the MILP and the LP relaxations for a bilinear term is as follows:","category":"page"},{"location":"api/","page":"API","title":"API","text":"construct_bilinear_relaxation!","category":"page"},{"location":"api/#PolyhedralRelaxations.construct_bilinear_relaxation!","page":"API","title":"PolyhedralRelaxations.construct_bilinear_relaxation!","text":"construct_bilinear_relaxation!(m,x,y,z,x_partition,y_partition)\n\nAdd polyhedral relaxation of z = xy to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::Jump.Model: model to which relaxation is to be added.\nx::Jump.VariableRef: JuMP variable x.\ny::JuMP.VariableRef: JuMP variable y.\nz::JuMP.VariableRef: JuMP variable z.\nx_partition::Vector{<:Real}: partition of the domain of x.\ny_partition::Vector{<:Real}: partition of the domain of y.\n\nOptional Arguments\n\nvariable_pre_base_name::AbstractString: base_name that needs to be added to the auxiliary   variables for meaningful LP files\n\nThis function builds an incremental formulation, and currently supports more than  one partition only on one of the variables x or y and not on both. It will  throw an error when more than one partitions are provided on both variables.  When exactly one partition is input for both variables, it populates the model  with the McCormick relaxation. The incremental formulation is similar to the triangle  chain relaxation in the manuscript with the triangles replaced with tetrahedrons.  Adjacent tetrahedrons share an edge (instead of a point in the triangles case). \n\n\n\n\n\n","category":"function"},{"location":"api/#Additional-Algorithms-for-Relaxations-of-Univariate-Functions","page":"API","title":"Additional Algorithms for Relaxations of Univariate Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Apart from providing MILP and LP relaxations of graphs of univariate function y=f(x) for a given partition, the package also implements some basic partitioning algorithms to refine the partition and provide tighter relaxations. Given a partition, PolyhedralRelaxations.jl can refine the partition using an interval-bisection algorithm detailed in the following reference: ","category":"page"},{"location":"api/","page":"API","title":"API","text":"K. Sundar, S. Sanjeevi, and H, Nagarajan (2020). Sequence of Polyhedral Relaxations for Nonlinear Univariate Functions. (arxiv link)","category":"page"},{"location":"api/","page":"API","title":"API","text":"The partition refinement scheme is equipped with multiple stopping criteria that can be toggled by setting non-default values to the following keyword arguments in the standard API:","category":"page"},{"location":"api/","page":"API","title":"API","text":"error_tolerance: this parameter measures the maximum vertical distance between the under- and over-estimators of the relaxation within the domain of the univariate function. By default, this value is set to NaN64. Setting a non-zero positive value for this parameter would result partition and a corresponding relaxation such that the maximum vertical distance between the under- and over-estimators of the relaxation is at most the value prescribed by error_tolerance. \nnum_additional_partitions: this parameter as the name suggests will refine the partition using the interval bisection algorithm till the total number of additional partitions reaches this number. It's default value is set to 0. ","category":"page"},{"location":"api/","page":"API","title":"API","text":"The refinement algorithm will stop if either of the above two stopping criteria is satisfied. ","category":"page"},{"location":"api/#Tolerance-parameters","page":"API","title":"Tolerance parameters","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"The main functions to produce the relaxations are also equipped with the following two tolerance parameters:","category":"page"},{"location":"api/","page":"API","title":"API","text":"length_tolerance: this parameter is used to control the refinement algorithm. A partition whose length is less than the length_tolerance is not partitioned further. The default value of this parameter is epsilon = 1 times 10^-6.\nderivative_tolerance: when the refinement algorithm is used with the base_partition not containing the inflection points of the function in its domain, the resulting relaxations will be erroneous i.e., there is no guarantee that the relaxation obtained is even valid. One necessary condition to detect this issue is by ensuring that the derivatives at successive partition points are not equal. This condition is checked up to the tolerance specified by this parameter. The default value of this parameter is epsilon = 1 times 10^-6.","category":"page"},{"location":"interface/#Using-with-JuMP","page":"Interfacing with JuMP","title":"Using with JuMP","text":"","category":"section"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"This section provides an example of how to use the relaxations provided by PolyhdedralRelaxations in conjunction with JuMP.","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"The following examples illustrate the interfacing code for y = x^3 on the partition -10 -075 -05 -025 00 025 05 075 10. ","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"# Create MILP relaxation \nusing PolyhderalRelaxations, JuMP, HiGHS\nmilp_optimizer = JuMP.optimizer_with_attributes(HiGHS.Optimizer, \"presolve\" => \"on\")\n\nf, partition = x -> x^3, collect(-1.0:0.25:1.0)\n\n# create the MILP relaxation of the univariate function.\nmilp = Model(milp_optimizer)\nJuMP.@variable(milp, -1.0 <= x <= 1.0)\nJuMP.@variable(milp, y)\nformulation_info_milp = construct_univariate_relaxation!(milp, f, x, y, partition, true)\n\n# create the LP relaxation of the univariate function.\nlp = Model(milp_optimizer)\nJuMP.@variable(lp, -1.0 <= x_lp <= 1.0)\nJuMP.@variable(lp, y_lp)\nformulation_info_lp = construct_univariate_relaxation!(milp, f, x_lp, y_lp, partition, false)","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"The formulation_info_milp and formulation_info_lp contains variable and constraint references for all the additional variables and constraints that are used to formulate the polyhedral relaxation. It definition can be found in FormulationInfo. A similar syntax holds for bilinear relaxations as well. Users are referred to construct_bilinear_relaxation! for the documentation of the function for constructing a relaxation for bilinear terms.","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"The reader is referred to manuscript for details on the formulation.","category":"page"},{"location":"interface/","page":"Interfacing with JuMP","title":"Interfacing with JuMP","text":"For an exhaustive list of functions, the reader is referred to PolyhedralRelaxations.jl Function Reference. ","category":"page"},{"location":"reference/#PolyhedralRelaxations.jl-Function-Reference","page":"Reference","title":"PolyhedralRelaxations.jl Function Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [PolyhedralRelaxations]","category":"page"},{"location":"reference/#PolyhedralRelaxations.FormulationInfo","page":"Reference","title":"PolyhedralRelaxations.FormulationInfo","text":"The struct FormulationInfo holds two dictionaries, one for variable references and the other for constraint references.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations.FormulationInfo-Tuple{}","page":"Reference","title":"PolyhedralRelaxations.FormulationInfo","text":"Empty contructor for struct FormulationInfo\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.UnivariateFunctionData","page":"Reference","title":"PolyhedralRelaxations.UnivariateFunctionData","text":"The struct UnivariateFunctionData holds the inputs provided by the user. It takes in the function and its derivative (as lambda expressions), the partition on the independent variable that the user provides, and the following 3 tolerance values:\n\nerror tolerance denotes the strength of the relaxation (the closer to zero   the stronger the relaxation)\nlength tolerance (maximum difference between successive derivative values)\nderivative tolerance denotes the tolerance for checking equality of   derivative values at subsequent partition points, and finally, the maximum   number of additional partition intervals.\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations.Vertex2d","page":"Reference","title":"PolyhedralRelaxations.Vertex2d","text":"Vertex2d is a pair (x y)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations.Vertex3d","page":"Reference","title":"PolyhedralRelaxations.Vertex3d","text":"Vertex3d is a pair (x y z)\n\n\n\n\n\n","category":"type"},{"location":"reference/#PolyhedralRelaxations._at_point!-Tuple{Vector{<:Real}, Real}","page":"Reference","title":"PolyhedralRelaxations._at_point!","text":"_at_point!(partition::Vector{<:Real}, point::T where {T<:Real})::RefinementInfo\n\nThis scheme adds the point to the partition. \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._bisect!-Tuple{Vector{<:Real}, Float64, Float64}","page":"Reference","title":"PolyhedralRelaxations._bisect!","text":"_bisect!(partition::Vector{<:Real}, lower::Float64, upper::Float64)::RefinementInfo\n\nThis scheme bisects the partition defined by lower and upper values.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._bisect_all!-Tuple{Vector{<:Real}, Float64}","page":"Reference","title":"PolyhedralRelaxations._bisect_all!","text":"_bisect_all!(partition::Vector{<:Real}, refinement_width_tol::Float64)::RefinementInfo\n\nThis scheme bisects every partition provided the width of the partition is greater than refinement_width_tol value.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_bilinear_milp_relaxation!-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef, Vector{<:Real}, Vector{<:Real}, AbstractString}","page":"Reference","title":"PolyhedralRelaxations._build_bilinear_milp_relaxation!","text":"_build_bilinear_relaxation!(m, x, y, z, x_partition, y_partition, pre_base_name)\n\nBuild incremental formulation for z = xy given partition data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_linking_constraints!-Tuple{JuMP.Model, Dict{T, FormulationInfo} where T, Dict{JuMP.VariableRef, Vector{T}} where T<:Real, Dict}","page":"Reference","title":"PolyhedralRelaxations._build_linking_constraints!","text":"buildlinking_constraints!(m, info, partitions, helper)\n\nBuild a linking constraints using the lamba variables for  multilinear terms that share more than 2 variables. \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_mccormick_relaxation!-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef}","page":"Reference","title":"PolyhedralRelaxations._build_mccormick_relaxation!","text":"_build_mccormick_relaxation!(m, x, y, z)\n\nMcCormick relaxation of binlinear term \n\nz >= JuMP.lower_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.lower_bound(x)*JuMP.lower_bound(y)\nz >= JuMP.upper_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.upper_bound(x)*JuMP.upper_bound(y)\nz <= JuMP.lower_bound(x)*y + JuMP.upper_bound(y)*x - JuMP.lower_bound(x)*JuMP.upper_bound(y)\nz <= JuMP.upper_bound(x)*y + JuMP.lower_bound(y)*x - JuMP.upper_bound(x)*JuMP.lower_bound(y)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_multilinear_convex_hull_relaxation!-Tuple{JuMP.Model, Tuple, JuMP.VariableRef, Dict{JuMP.VariableRef, Vector{T}} where T<:Real, AbstractString}","page":"Reference","title":"PolyhedralRelaxations._build_multilinear_convex_hull_relaxation!","text":"_build_multilinear_convex_hull_relaxation!(m, x, z, partitions, pre_base_name)\n\nBuild a convex hull formulation LP for  for z = prod(x) given partition data. \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_multilinear_sos2_relaxation!-Tuple{JuMP.Model, Tuple, JuMP.VariableRef, Dict{JuMP.VariableRef, Vector{T}} where T<:Real, AbstractString}","page":"Reference","title":"PolyhedralRelaxations._build_multilinear_sos2_relaxation!","text":"_build_multilinear_milp_relaxation!(m, x, z, partitions, pre_base_name)\n\nBuild a piecewise polyhedral relaxation for  for z = prod(x) given partition data. \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_univariate_lp_relaxation!-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, UnivariateFunctionData, AbstractString}","page":"Reference","title":"PolyhedralRelaxations._build_univariate_lp_relaxation!","text":"_build_univariate_lp_relaxation!(m, x, y, univariate_function_data, pre_base_name)\n\nBuild LP relaxation for y=f(x) given the univariate function data.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._build_univariate_milp_relaxation!-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, UnivariateFunctionData, AbstractString}","page":"Reference","title":"PolyhedralRelaxations._build_univariate_milp_relaxation!","text":"_build_univariate_milp_relaxation!(m,x,y,function_data,pre_base_name)\n\nReturn a MILPRelaxation object with constraint and RHS information of the MILP formulation of the polyhedral relaxation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._check_if_linking_constraints_are_needed-Tuple{Dict{T, FormulationInfo} where T, Union{Nothing, Int64}}","page":"Reference","title":"PolyhedralRelaxations._check_if_linking_constraints_are_needed","text":"_check_if_linking_constraints_are_needed(\n    info::Dict{T,FormulationInfo} where {T<:Any}, \n    degree_limit::Union{Nothing,T} where {T<:Int64}\n)::NamedTuple\n\nThis function checks to see if linking constraints are  required given the vector of each multilinear terms'  FormulationInfo struct \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._collect_bilinear_vertices-Tuple{Vector{<:Real}, Vector{<:Real}}","page":"Reference","title":"PolyhedralRelaxations._collect_bilinear_vertices","text":"_collect_bilinear_vertices(x_partition, y_partition)\n\nReturn a pair of lists with origin vertices as the first element  and the non origin vertices as the second element.\n\nEach vertex is an object of the struct Vertex3d (x y xy)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._collect_vertices-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._collect_vertices","text":"_collect_vertices(univariate_function_data)\n\nReturn a pair of lists with secant vertices as the first element and tangent vertices as the second element.\n\nEach element in the secant vertex list is a pair (x,y) where\n\nx is an element of univariate_function_data.partition,\ny is the value of the given univariate function at x.\n\nAll secant vertices lie on the curve.\n\nEach element in the tangent vertex list is also a pair (x,y). Each position i of the list contains the vertex formed by intersection of tangents of the curve y=univariate_function_data.f(x) at secant_vertices[i] and secant_vertices[i+1]. No tangent vertex will lie on the curve (except for the trivial case where the curve is linear, and all triangles are flat lines).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_error_bound-Tuple{Function, Float64, Float64}","page":"Reference","title":"PolyhedralRelaxations._get_error_bound","text":"_get_error_bound(derivative, lb, ub)\n\nGet error bound of a function with derivative derivative in the closed interval [lb,ub].\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_error_queue-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._get_error_queue","text":"_get_error_queue(univariate_function_data)\n\nBuild a max-priority-queue holding errors of each partition interval in univariate_function_data.partition. Keys of the queue are indices of starting positions of the partition interval in univariate_function_data.partition. Priorities are error bounds of partition intervals. The queue is built as a max-queue for easy access to the  maximum error.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_lp_relaxation_vertices-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._get_lp_relaxation_vertices","text":"_get_lp_relaxation_vertices(univariate_function_data::UnivariateFunctionData)::Vector{Vertex2d}\n\nReturn vertices of the LP relaxation of the given function.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_max_error_bound-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._get_max_error_bound","text":"_get_max_error_bound(univariate_function_data)\n\nCompute and return maximum value of error bound among all partition intervals.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_slice_indices-Tuple{Int64, Int64, Any}","page":"Reference","title":"PolyhedralRelaxations._get_slice_indices","text":"_get_slice_indices(var_id::Int64, slice_id::Int64, cartesian_indices)::Vector\n\nHelper function to get all the linear indices corresponding to a variable and slice \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._get_tangent_vertex-Tuple{Pair{<:Real, <:Real}, Pair{<:Real, <:Real}, Function}","page":"Reference","title":"PolyhedralRelaxations._get_tangent_vertex","text":"_get_tangent_vertex(prev_secant_vertex, next_secant_vertex, derivative)\n\nReturn (xy) coordinates of the intersection of tangents drawn at prev_secant_vertex and next_secant_vertex.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._is_refinement_feasible-Tuple{UnivariateFunctionData, DataStructures.PriorityQueue}","page":"Reference","title":"PolyhedralRelaxations._is_refinement_feasible","text":"_is_refinement_feasible(univariate_function_data, error_queue)\n\nThis function checks if the refinement is feasible\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._make_filtered_logger-Tuple{Any}","page":"Reference","title":"PolyhedralRelaxations._make_filtered_logger","text":"_make_filtered_logger(level::Logging.LogLevel)\n\nHelper function to create the filtered logger for PMD\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._non_uniform!-Tuple{Vector{<:Real}, Real, Float64, Float64, Float64, Float64}","page":"Reference","title":"PolyhedralRelaxations._non_uniform!","text":"_non_uniform!(partition, point, lower, upper, added_point_width_tol, ratio)::RefinementInfo\n\nThis scheme adds a small partition around the point using the ratio provided while  satisfying the added_point_width_tolerance\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._pr_metafmt-Tuple{Base.CoreLogging.LogLevel, Any, Any, Any, Any, Any}","page":"Reference","title":"PolyhedralRelaxations._pr_metafmt","text":"_pr_metafmt(level::Logging.LogLevel, _module, group, id, file, line)\n\nMetaFormatter for ConsoleLogger for PR to adjust log message format\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._refine_partition!-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._refine_partition!","text":"_refine_partition!(univariate_function_data)\n\nPartition refinement schemes (interval bisection)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._refine_partition!-Tuple{Vector{<:Real}, Real, Symbol, Float64, Float64, Float64, Bool}","page":"Reference","title":"PolyhedralRelaxations._refine_partition!","text":"_refine_partition!(\n    partition::Vector{<:Real}, \n    point::T where {T<:Real},\n    refinement_type::REFINEMENT_TYPE,\n    refinement_ratio::Float64, \n    refinement_width_tol::Float64,\n    refinement_added_point_width_tolerance::Float64,\n    refine_largest::Bool)::RefinementInfo\n\nInternal helper function to help in partition refinement         \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate-Tuple{JuMP.VariableRef, JuMP.VariableRef, Vector{<:Real}, Vector{<:Real}}","page":"Reference","title":"PolyhedralRelaxations._validate","text":"_validate(x, y, x_partition, y_partition)\n\nVariable bounds and partition consistency checker for bilinear terms\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate-Tuple{JuMP.VariableRef, Vector{<:Real}}","page":"Reference","title":"PolyhedralRelaxations._validate","text":"_validate(x, partition)\n\nVariable bounds and partition consistency checker\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate-Tuple{Tuple, Dict{JuMP.VariableRef, Vector{T}} where T<:Real}","page":"Reference","title":"PolyhedralRelaxations._validate","text":"_validate(x, partitions)\n\nVariable bounds and partition consistency checker\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate-Tuple{UnivariateFunctionData}","page":"Reference","title":"PolyhedralRelaxations._validate","text":"_validate(univariate_function_data)\n\nInput univariate function data validator\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._validate_point-Tuple{UnivariateFunctionData, Float64}","page":"Reference","title":"PolyhedralRelaxations._validate_point","text":"_validate_point(univariate_function_data, x)\n\nInput data point validator\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations._variable_domain-Tuple{JuMP.VariableRef}","page":"Reference","title":"PolyhedralRelaxations._variable_domain","text":"function _variable_domain(var)\n\nComputes the valid domain of a given JuMP variable taking into account bounds and the varaible's implicit bounds (e.g. binary).\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.add_multilinear_linking_constraints!-Tuple{JuMP.Model, Dict{T, FormulationInfo} where T, Dict{JuMP.VariableRef, Vector{T}} where T<:Real}","page":"Reference","title":"PolyhedralRelaxations.add_multilinear_linking_constraints!","text":"add_multilinear_linking_constraints!(m, info, partitions; max_degree_limit = nothing, \n    helper = Dict())::FormulationInfo\n\nAdd linking constraints for the different multilinear relaxations  in the model using the lambda variables for each relaxation. \n\nReference information:     Jongeun Kim, Jean-Philippe P. Richard, Mohit Tawarmalani,      Piecewise Polyhedral Relaxations of Multilinear Optimization,      http://www.optimization-online.org/DB_HTML/2022/07/8974.html\n\nMandatory Arguments\n\nm::Jump.Model: model to which relaxation is to be added.\ninfo::Dict{T,FormulationInfo} where {T<:Any}: dictionary keyed \n\nby tuple of variables involved in multilinear term whose value is  the FormulationInfo struct returned by added the multilinear  relaxation for that term\n\npartitions::Dict{JuMP.VariableRef,Vector{T}} where {T<:Real}: partition \n\nof the domain of the variables.\n\nOptional Keyword Arguments\n\nmax_degree_limit::Union{Nothing,T} where {T<:Int64}: this is a \n\ncontrol factor for limit the number of linking constraints added.  Default value is nothing which will not limit the number of constraints added. \n\nhelper::Dict - default is the empty dictionary. This dictionary \n\ncontains the common subterms that are shared between the different  multilinear terms. When the function is invoked the first time,  the FormulationInfo returned contains this dictionary in  extra[:common_subterm_data]. When invoked the subsequent times,  passing this dictionary can save a lot on the computation time required  to generate these constraints.  \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.construct_bilinear_relaxation!-Tuple{JuMP.Model, JuMP.VariableRef, JuMP.VariableRef, JuMP.VariableRef, Vector{<:Real}, Vector{<:Real}}","page":"Reference","title":"PolyhedralRelaxations.construct_bilinear_relaxation!","text":"construct_bilinear_relaxation!(m,x,y,z,x_partition,y_partition)\n\nAdd polyhedral relaxation of z = xy to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::Jump.Model: model to which relaxation is to be added.\nx::Jump.VariableRef: JuMP variable x.\ny::JuMP.VariableRef: JuMP variable y.\nz::JuMP.VariableRef: JuMP variable z.\nx_partition::Vector{<:Real}: partition of the domain of x.\ny_partition::Vector{<:Real}: partition of the domain of y.\n\nOptional Arguments\n\nvariable_pre_base_name::AbstractString: base_name that needs to be added to the auxiliary   variables for meaningful LP files\n\nThis function builds an incremental formulation, and currently supports more than  one partition only on one of the variables x or y and not on both. It will  throw an error when more than one partitions are provided on both variables.  When exactly one partition is input for both variables, it populates the model  with the McCormick relaxation. The incremental formulation is similar to the triangle  chain relaxation in the manuscript with the triangles replaced with tetrahedrons.  Adjacent tetrahedrons share an edge (instead of a point in the triangles case). \n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.construct_multilinear_relaxation!","page":"Reference","title":"PolyhedralRelaxations.construct_multilinear_relaxation!","text":"construct_multilinear_relaxation!(m,x,y,z,x_partition,y_partition)\n\nAdd polyhedral relaxation of z = product(x) to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::Jump.Model: model to which relaxation is to be added.\nx::Tuple: JuMP variables in the multilinear term as a tuple.\nz::JuMP.VariableRef: JuMP variable z.\npartitions::Dict{JuMP.VariableRef,Vector{T}} where {T<:Real}: partition \n\nof the domain of the x variables.\n\nOptional Arguments\n\nvariable_pre_base_name::AbstractString: base_name that needs \n\nto be added to the auxiliary variables for meaningful LP files\n\nThis function builds an lambda based SOS2 formulation for the piecewise polyhedral relaxation.  Reference information:     Kaarthik Sundar, Harsha Nagarajan, Jeff Linderoth, Site Wang,      Russell Bent, Piecewise Polyhedral Formulations for a Multilinear Term,      https://arxiv.org/abs/2001.00514 \n\n\n\n\n\n","category":"function"},{"location":"reference/#PolyhedralRelaxations.construct_univariate_relaxation!-Tuple{JuMP.Model, Function, JuMP.VariableRef, JuMP.VariableRef, Vector{<:Real}, Bool}","page":"Reference","title":"PolyhedralRelaxations.construct_univariate_relaxation!","text":"construct_univariate_relaxation!(m,f,x,y,x_partition;f_dash=x->ForwardDiff.derivative(f,x),error_tolerance=NaN64,length_tolerance=1e-6,derivative_tolerance=1e-6,num_additional_partitions=0)\n\nAdd MILP relaxation of y=f(x) to given JuMP model and return an object with new variables and constraints.\n\nMandatory Arguments\n\nm::JuMP.Model: model to which relaxation is to be added.\nf::Function: function or oracle for which a polyhedral relaxation is   required, usually non-linear.\nx::JuMP.VariableRef: JuMP variable for domain of f.\ny::JuMP.VariableRef: JuMP variable for evaluation of f.\nx_partition::Vector{<:Real}: partition of the domain of f.\nmilp::Bool: build MILP relaxation if true, LP relaxation otherwise. Note   that the MILP relaxation uses the incremental formulation presented in the   paper, but the LP relaxation uses a lambda form that builds a formulation   as the convex combination of triangle vertices that are at the intersection   of tangents to the curve.\n\nOptional Arguments\n\nf_dash::Function: function or oracle for derivative of f, defaults to    the derivative function from the ForwardDiff package.\nerror_tolerance::Float64: Maximum allowed vertical distance between over   and under estimators of f, defaults to NaN64.\nlength_tolerance::Float64: maximum length of a sub-interval in a partition,   defaults to 1 times 10^-6.\nderivative_tolerance::Float64: minimum absolute difference between   derivaties at successive elements of a partition for them to be considered   different, defaults to 1 times 10^-6. If the difference of a partition sub-interval   is smaller than this value, that sub-interval will be refined.\nnum_additional_partitions::Int64: budget on number of sub-intervals in   partition, defaults to 0. Note that if the number of partitions is n and   the number of additional partitions is m, then the function will return a   relaxation with at most n+m partitions.\nvariable_pre_base_name::AbstractString: base_name that needs to be added to the auxiliary   variables for meaningful LP files\n\nAssume that:\n\nf is a bounded function of 1 variable.\nx_partition is a partition of the domain of f such that f is either   convex or concave each sub-interval of the partition.\nf_dash is not equal at two consecutive elements of x_partition.\n\nThis function builds an incremental formulation, which is the formulation presented in the paper.\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.reset_logging_level!-Tuple{}","page":"Reference","title":"PolyhedralRelaxations.reset_logging_level!","text":"reset_logging_level!()\n\nResets the log level to Info\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.restore_global_logger!-Tuple{}","page":"Reference","title":"PolyhedralRelaxations.restore_global_logger!","text":"restore_global_logger!()\n\nRestores the global logger to its default state (before PMD was loaded)\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.set_logging_level!-Tuple{Symbol}","page":"Reference","title":"PolyhedralRelaxations.set_logging_level!","text":"set_logging_level!(level::Symbol)\n\nSets the logging level for PR: :Info, :Warn, :Error, :Debug\n\n\n\n\n\n","category":"method"},{"location":"reference/#PolyhedralRelaxations.silence!-Tuple{}","page":"Reference","title":"PolyhedralRelaxations.silence!","text":"silence!()\n\nSets loglevel for PMD to :Error, silencing Info and Warn\n\n\n\n\n\n","category":"method"},{"location":"#PolyhedralRelaxations.jl-Documentation","page":"Introduction","title":"PolyhedralRelaxations.jl Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = PolyhedralRelaxations","category":"page"},{"location":"#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"PolyhedralRelaxations.jl is a Julia/JuMP package for constructing Polyhedral Relaxations for two classes of functions (i) graphs of bounded, differentiable, univariate functions (ii) single bilinear term. For the function class (i) it can be used to construct a sequence of both MILP and LP relaxation that converge to the graph of the univariate function and its convex hull, respectively. It takes in the function with its domain and the JuMP variables and the JuMP model and populates the model with the relaxation. It returns variable and constraint references for the formulated relaxation. For bilinear terms, it takes the JuMP variables and the JuMP model with partitions on each variable involved in the bilinear term and populates the model with the relaxation. Similar to the univariate function relaxations, bilinear relaxation function returns the variable and constraint references for the formulated relaxation. ","category":"page"},{"location":"#Installation-Guide","page":"Introduction","title":"Installation Guide","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To use PolyhedralRelaxations, first download and install Julia or open up a remote notebook at JuliaBox or similar services.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This version of PolyhedralRelaxations is compatible with Julia 1.0 and later.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From Julia REPL, PolyhedralRelaxations is installed by using the built-in package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.add(\"PolyhedralRelaxations\")","category":"page"},{"location":"#Unit-Tests","page":"Introduction","title":"Unit Tests","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"To run the tests in the package, run the following command within the Julia REPL after installing the package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"import Pkg\nPkg.test(\"PolyhedralRelaxations\")","category":"page"},{"location":"#Quick-Introduction-to-the-Theory","page":"Introduction","title":"Quick Introduction to the Theory","text":"","category":"section"},{"location":"#Geometry-of-relaxations-for-univariate-functions","page":"Introduction","title":"Geometry of relaxations for univariate functions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This quick start guide will introduce the main concepts of PolyhedralRelaxations. The package constructs MILP and LP relaxations for y = f(x), given the function and discretization points on the domain of f(x). For instance, given y=x^3 and a partition of the domain -15 0 2, it constructs an MILP relaxation of y = x^3 as the disjunction of the triangles shown in the figure below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: example)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Notice from the above example that, for the above disjunction of triangles to be a valid relaxation for y = f(x), the partition points must necessarily include the inflection points of the univariate function. Also, in the above example, the domain of the function y = x^3 is given by -15 2. The following table provides a list of inflection points for various well-used univariate functions. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Function Inflection points\nx^n (n is odd) 0\nx^n (n is even) phi\nsin x npi (n in mathbb Z)\ncos x nfracpi2 (n is odd )\nxx 0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If the domain of the provided function contains an inflection point, then the requirement is that the inflection points should be provided as a discretization point; failing which the MILP relaxation need not be valid for the given function. ","category":"page"},{"location":"#Type-of-formulation-used","page":"Introduction","title":"Type of formulation used","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The MILP formulation, obtained as the disjunction of the triangles, is formulated using the incremental method (using the so-called delta variables) and the convex hull of the triangles (the LP) is formulated using the standard lambda-method (V-representation). For details on the formulation and theoretical properties, interested readers are referred to the following paper:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"K. Sundar, S. Sanjeevi, and H, Nagarajan (2020). Sequence of Polyhedral Relaxations for Nonlinear Univariate Functions. (arxiv link)","category":"page"},{"location":"#Geometry-of-relaxation-for-a-bilinear-term","page":"Introduction","title":"Geometry of relaxation for a bilinear term","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Let us consider the bilinear term z=x_1 x_2. Suppose -1 1 are the bounds on x_1 and x_2. Then the convex hull of z=x_1 x_2 is given by the McCormick relaxation (a tetrahedron). The bilinear relaxation is then given by the four facets of the tetrahedron shown in the figure below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: McCormick relaxation)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Now suppose that for the variable x_2, we have partitioned the domain  has more partitions specified into -10 -025 025 10, then the bilinear relaxation can be used to formulate an MILP relaxation that is given by the disjunction of three tetrahedrons shown in the figure below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: MILP relaxation)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Similar to the univariate MILP relaxations, an incremental method is used to formulate this disjunction of tetrahedrons. To the best of our knowledge, this incremental formulation is not found any where in the literature and is assumed to be common knowledge. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently the package does not support more than one partition on both the variables x_1 and x_2. Nevertheless, this support will be added in the future versions. ","category":"page"}]
}
